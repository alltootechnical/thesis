\subsection{Evaluating Cryptographic Security}
After performing tests to evaluate image quality, we then perform tests for cryptographic security, as enumerated in~\cite{ahmed_benchmark_2016}: entropy analysis, correlation coefficient analysis (CC), NPCR and UACI.
\begin{description}
	\item [Information entropy analysis.] In information theory, the entropy function $H(X)$ is defined in~\cite{bauer_information_2005} as
	\begin{align}
		H(X) = - \sum_{a:p_X(a)>0}{p_X(a)\log_2{p_X(a)}}
	\end{align}
	where $p_X(a)$ denotes the probability that the random variable $X$ takes on the value $a$.
	In the analysis of image encryption, $H(X)$ is computed for the values of the ciphertext pixels. To ensure security against entropy attacks, $H(X)$ must be as close as possible to $\log_2{N}$, where $N$ is the number of possible pixel values~\cite{ahmed_benchmark_2016}.

    We will compute $H(\mathrm{CDT})$ for every image operation, under each homomorphic cryptosystem, and compare the effects of each image operation on the entropy of the encrypted image. Ideally, performing image operations on encrypted images should still maintain a high level of entropy.
	\item [Correlation coefficient analysis (CC).]
		Images generally have a high degree of similarity between adjacent pixels. This correlation must be hidden in the encrypted image, even after performing image operations.
		The correlation coefficient of an image can be computed between adjacent pixels either vertically, horizontal, or diagonally, and is defined in~\cite{ahmed_benchmark_2016} by:
		\begin{align}
            \mathrm{CC}(X,Y) = \frac{\sigma_{X,Y}}{\sqrt{\sigma_X}\times\sqrt{\sigma_Y}}
		\end{align}
		where
		\begin{itemize}
			\item $\sigma_X, \sigma_Y$ are the variances of $X$ and $Y$, respectively;
			\item $\sigma_{XY}$ is the covariance of $X$ and $Y$.
		\end{itemize}

        For every $\mathrm{CDT}$ image, we will compute for the correlation coefficient (for vertical, horizontal and diagonal correlation) for every image operation, under each homomorphic cryptosystem.
	\item [NPCR and UACI.]
		The Number of Pixel Change Rate (NPCR) measures the number of pixels which are changed between the a plaintext and a ciphertext to quantify the amount of dispersion which occurs during encryption.

		On the other hand, the Universal Average Change Intensity (UACI) measures the average difference in pixel intensity between two images.

		The NPCR and UACI between two images $X$ and $Y$, each containing $N$ pixels indexed from $1$ to $N$ is defined in~\cite{wu_npcr_2011} as
		\begin{align}
            \mathrm{NPCR}(X,Y) &= \frac{1}{N}\sum_{i = 1}^{N}{D(X_i,Y_i)} \times 100\%\\
            \mathrm{UACI}(X,Y) &= \frac{1}{L_{\max} \times N} \sum_{i = 1}^{N}{ |L(X_i) - L(Y_i)| } \times 100\%
		\end{align}
		where
		\begin{itemize}
			\item $X_i$ and $Y_i$ are the $i$th pixels of $X$ and $Y$, respectively;
			\item $D$ is a difference function between pixels $A$ and $B$ defined by
			\begin{align}
				D(A,B) =
				\begin{cases}
					0 &  \text{if $A = B$},\\
					1 &  \text{if $A \neq B$};
				\end{cases}
			\end{align}
		\item $L_{\max}$ is the maximum intensity of a pixel;
		\item $L(X_i)$ and $L(Y_i)$ are the intensities of pixels $X_i$ and $Y_i$, respectively.
		\end{itemize}
        We will calculate $\mathrm{NPCR}(\mathrm{PDT},\mathrm{CDT})$ and $\mathrm{UACI}(\mathrm{PDT},\mathrm{CDT})$  for every image operation, under each homomorphic cryptosystem. A high NPCR and UACI are desired to ensure high dispersion and security against differential attacks~\cite{ahmed_benchmark_2016}. Critical values for NPCR and UACI for given image sizes and bit depths are given in~\cite{wu_npcr_2011}.
\end{description}


%\subsection{DGK Comparison Protocol}
%The DGK system was primarily developed as part of a comparison protocol, a protocol which allows
%It is known that $E(m)^{v_pv_q} \bmod n = 1$ if and only if $m=0$. This allows

%\subsection{The Benaloh cryptosystem}
%The Benaloh cryptosystem, initially proposed by Josh Benaloh in \cite{benaloh_dense_1994}, allows for the encryption of integers in $\mathbb{Z}_r$ for some odd integer $r$. It relies on the hardness of the \textit{discrete logarithm problem}, and is a generalization of the classic Goldwasser--Micali cryptosystem~\cite{goldwasser_probabilistic_1984}. We present here a corrected version by Fousse, et al. \cite{fousse_benalohs_2010} which corrects an error in the key generation algorithm which prevents accurate decryption in some cases.

%\subsubsection{Benaloh Cryptosystem Description}
%We choose an integer $r$ and two large primes $p$ and $q$ such that the following conditions hold:
%\begin{itemize}
%  \item $r$ divides $(p-1)$;
%  \item $\mathrm{gcd}(r,(p-1)/r)=1$;
%  \item $\mathrm{gcd}(r,q-1)=1$.
%\end{itemize}
%Next, let $n=pq$ and $\phi = (p-1)(q-1)$, and choose $y\in \mathbb{Z}_n^* = \{ x \in \mathbb{Z}_n | \mathrm{gcd}(x,n)=1 \}$ such that the following conditions hold:
%\begin{itemize}
%  \item $y^{\phi/r}\neq 1 \bmod n$;
%  \item For all prime factors $s$ of $r$, $y^{\phi/s}\neq 1 \bmod n$.
%\end{itemize}
%We denote the public key to be $(y,r,n)$ and the private key to be $(p,q)$.

%The encryption function to encrypt a plaintext $m \in \mathbb{Z}_r$ is defined as
%\begin{align*}
%  E(m) = y^m \cdot u^r \mod{n},
%\end{align*}
%where $u$ is a random integer in $\mathbb{Z}_n^*$.

%The decryption function to decrypt a ciphertext $c \in \mathbb{Z}_{n}$ is defined as:
%\begin{align*}
%  D(c) = \log_x{c^{\phi/r}} \mod n
%\end{align*}
%where $x = y^{\phi/r}$ and $\log_x{y} = k$ such that $x^k = y \bmod n$.

%Decryption requires the computation of the discrete logarithm, which can be done using a linear search when $r$ is small. For large values of $r$, the baby-step giant-step algorithm can be used to perform decryption in $O(\sqrt{r})$ time \cite{benaloh_dense_1994}.

%\subsubsection{Homomorphic Properties of the Benaloh Cryptosystem}
%Similar to the Paillier cryptosystem, the Benaloh cryptosystem supports additive homomorphism as well as the multiplication of a plaintext scalar to an encrypted message.
%For all $m_1,m_2 \in \mathbb{Z}_r$ and $k\in \mathbb{N}$, the following homomorphic properties hold.
%\begin{description}
%  \item[Additive homomorphism]
%  \begin{align*}
%    D(E(m_1)y^{m_2}\bmod n^2)=(m_1+m_2)\bmod n & \text{ (used to add a constant)}\\
%    D(E(m_1)E(m_2)\bmod n^2)=(m_1+m_2)\bmod n & \text{ (used for binary addition)}
%  \end{align*}
%  \item[Multiplicative homomorphism]
%  \begin{align*}
%    D(E(m_1)^k\bmod n)= km_1\bmod n & \text{ (used to multiply a plaintext constant)}
%  \end{align*}
%\end{description}

%As the multiplicative homomorphism was not presented in the original paper, we provide a short proof here.
%\begin{proof}
%  Let $m \in \mathbb{Z}_r$ and $k\in \mathbb{N}$.
%  We consider $E(m)^k\bmod n = (y^m \cdot u^r \bmod{n})^k\bmod n$.
%  \begin{align*}
%    (y^m \cdot u^r \bmod{n})^k\bmod n
%    &= (y^m \cdot u^r)^k \bmod{n}\\
%    &= (y^m)^k \cdot (u^r)^k \bmod{n}\\
%    &= y^{km} \cdot (u^k)^r \bmod{n}\\
%    &= y^{km} \cdot (u^k \bmod{n})^r \bmod{n}
%  \end{align*}
%  Since $u$ is a random integer in $\mathbb{Z}_n^*$, $\mathrm{gcd}(u,n)=1$.
%  This implies $\mathrm{gcd}(u^k,n)=1$, so $u^k \bmod n$ is a random integer in $\mathbb{Z}_n^*$.
%  Therefore, $y^{km} \cdot (u^k \bmod{n})^r \bmod{n} = E(m)^k\bmod n$ is a valid encryption of the message $km$.
%\end{proof}

% \subsection{Secure Exponentiation and Multiplication Protocols}
% \label{ssec:exponentiationprotocol}
% In order to perform polynomial evaluation, we first present a protocol for privacy-preserving exponentiation to a positive integer power, adapted from the protocol to calculate Euclidean distances used in \cite{hutchison_privacy-preserving_2009}.

% The following protocols apply to both the Paillier and DGK cryptosystems, as they share similar homomorphisms. We first present a secure squaring protocol.

% Suppose Alice encrypts an integer $x$ and sends it so Bob has $E(x)$, and wants to obtain $E(x^2)$ without exposing the value of $x$.
% \begin{itemize}
% 	\item Bob first selects a random integer $r$ and computes $E(x+r)$. Bob can do this since $r$ is a plaintext constant.
% 	\item Bob sends $E(x+r)$ to Alice, who decrypts the ciphertext to obtain $x+r$.
% 	\item Alice squares $x+r$ and encrypts the result. She sends $E((x+r)^2)$ to Bob.
% 	\item Bob computes $E(-2rx + r^2)$. He then computes $E((x+r)^2)E(-2rx + r^2) = E(x^2)$.
% \end{itemize}

% We can use the secure squaring protocol to arrive at a secure multiplication protocol, which then allows for the evaluation of polynomials.
% Suppose Alice encrypts integers $x$ and $y$, and Bob has $E(x), E(y)$ and wants to obtain $E(xy)$.
% \begin{itemize}
% 	\item Bob acquires $E(x^2), E(y^2)$ using the secure squaring protocol.
% 	\item Bob sends $E(x+y)$ to Alice, who decrypts the ciphertext to obtain $x+y$.
% 	\item Alice sends $E((x+y)^2)$ to Bob.
% 	\item Bob then computes
% 	\begin{align*}
% 		E((x+y)^2)E(x^2)^{-1}E(y^2)^{-1} &= E((x+y)^2 - x^2 - y^2)\\
% 		&= E(2xy)
% 	\end{align*}
% 	\item Bob can then recover $E(xy)$ by calcuating for the multiplicative inverse of 2 using the Euclidean algorithm, and calculating $2^{-1}E(xy)$. Such an inverse exists since the modulus is either a prime (in the DGK cryptosystem) or a product of primes greater than 2 (in the Paillier cryptosystem).
% \end{itemize}

\subsection{The Dasgupta--Pal Cryptosystem}
The Dasgupta--Pal cryptosystem is a fully homomorphic cryptosystem proposed in 2016 by Smaranika Dasgupta and S. K. Pal \cite{dasgupta_design_2016}, which encrypts integer plaintexts in $\mathbb{Z}_n$ to polynomial ciphertexts. We begin our presentation of the Dasgupta--Pal cryptosystem with the following definition.

Given a message $m \in \mathbb{Z}$, we denote
\begin{align*}
		m_p(x) = a_0 + a_1x + a_2x^2 + \cdots + a_kx^k
\end{align*}
where $a_ka_{k-1}\cdots a_2a_1_0$ is the binary representation of $m$.

In the original scheme presented in \cite{dasgupta_design_2016}, the secret key $S_k$ is set to be a large prime. In Appendix \ref{chap:correction}, we present a case where the Dasgupta--Pal cryptosystem fails and prove that setting the secret key $S_k = 2p$, where $p$ is a large prime, corrects errors in the Dasgupta--Pal cryptosystem.
We now decribe the correct cryptosystem.
\subsubsection{Corrected Dasgupta--Pal Cryptosystem Description}
Let $\ell$ denote the security parameter of the cryptosystem.
Let $S_k = 2p$, where $p$ is a prime number with $\ell - 1$ bits.
Choose a random even integer $z$ of length $\log_2{\ell}$.

Let the secret key be $S_k$, and let the refresh key be $R_k = z \cdot S_k$. The secret key is kept private to the encrypting/decrypting parties, while the refresh key is made publicly available.

The scheme defines the encryption algorithm for a message $m$ as follows:
\begin{align*}
	E(m) = y(x) + S_k\times d(x)
\end{align*}
where
$y(x)$ is a polynomial of degree $n$ such that $m_p(x) \equiv y(x) \bmod S_k$ and $d(x)$ is a randomly chosen polynomial of degree $n$. This encrypts each coefficient of of $m_p(x)$ by adding some multiple of $S_k$ to it. Through this process, each bit of the message is encrypted separately.

Furthermore, the decryption algorithm to recover $m_p(x)$ from a ciphertext polynomial $c(x)$ as
\begin{align*}
	m_p(x) = c(x) \bmod S_k \bmod 2.
\end{align*}
Thus $D(c(x))$ is defined as the integer recovered from the coefficients of the polynomial $c(x) \bmod S_k \bmod 2$.

Dasgupta and Pal note that homomorphic operations on ciphertext introduce noise which may interfere with decryption, due to the potential increase in ciphertext values.
To eliminate noise from a polynomial ciphertext, the following refresh function is used:
\begin{align*}
	R(c(x)) = c(x) \bmod R_k.
\end{align*}

\subsubsection{Homomorphic Properties of the Dasgupta--Pal Cryptosystem}
It has been shown \cite{dasgupta_design_2016} that the following properties hold for all integer messages $m_1, m_2 \in \mathbb{Z}_n$ in the Dasgupta--Pal cryptosystem. These properties arise since each coefficient in a ciphertext polynomial is essentially an independently encrypted bit of the original message.
\begin{description}
	\item[XOR on ciphertexts]
	A bitwise exclusive or (XOR) operation on integer messages can be achieved by adding the coefficients pairwise between two ciphertexts.
	\begin{align*}
		D(E(m_1)+E(m_2)) = m_1 \text{ XOR } m_2
	\end{align*}
	\item[AND on ciphertexts]
	Similarly, pair-wise multiplication corresponds to bitwise AND of integer messages.
	\begin{align*}
		D(E(a) \otimes E(b)) = a \text{ AND } b = ab \bmod 2
	\end{align*}
	where $\otimes$ denotes pairwise multiplication,
	\begin{align*}
		\sum_{i=1}^n{a_ix^i} \otimes \sum_{i=1}^n{b_ix^i} = \sum_{i=1}^n{a_ib_ix^i}.
	\end{align*}
\end{description}

Arbitrary computation on data can thus be achived using these bitwise operations. While the Dasgupta--Pal cryptosystem requires significant amounts of memory, as each bit of plaintext is encrypted into an integer, this approach provides a flexible method to perform relatively fast arbitrary computation on encrypted data. Encryption and decryption in the Dasgupta--Pal cryptosystem are accomplished using few arithmetic operations.
