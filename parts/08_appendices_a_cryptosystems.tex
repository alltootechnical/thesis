%\section{Introduction to the Appendices}

%The Appendices is where you are enabled to present any additional or supplementary information relevant to your study, yet do not require highlighting within the actual paper, either because of its trivial nature or volume. These may in the form of figures, tables, or additional text detailing specific aspects about or related to the study.

%\section{Sample Questions for Different Studies}
%The following table presents three sample studies, as well as the guide questions that may help direct the discussion in each section of the paper. You may use this as another reference in writing your paper.
\chapter{DESCRIPTION OF CRYPTOSYSTEMS}

\section{Proof of the Correction Dasgupta-Pal Cryptosystem}
The Dasgupta-Pal cryptosystem encrypts each bit in a bit string independently.
In terms of single-bit encryption, the Dasgupta-Pal cryptosystem can be described as follows:
\begin{description}
	\item[Key generation]
	Let the secret key, $S_k$ be a large prime.
	Let the public refresh key, $R_k$, be $S_k \times z$, where $z$ is a large even integer.
	\item[Encryption]
	Given a message $m$, the encryption function is defined as
	\begin{align*}
		E(m) = m + S_kr
	\end{align*}
	where $r$ is a random integer.
	\item[Decryption]
	Given a ciphertext $c$, the decryption function is defined as
	\begin{align*}
		D(c) = c \bmod S_k \bmod 2
	\end{align*}
\end{description}
The homomorphic operations are then defined as
\begin{description}
	\item[XOR on ciphertexts]
	\begin{align*}
		D(E(a)+E(b)) = a \text{ XOR } b
	\end{align*}
	\item[AND on ciphertexts]
	\begin{align*}
		D(E(a)\times E(b)) = a \text{ AND } b
	\end{align*}
\end{description}
After repeated operations on ciphertexts, the resulting ciphertext can grow in magnitude.
To prevent storage issues and keep the ciphertext size small, a refresh function is used.
\begin{description}
	\item[Refresh function]
	Given a ciphertext $c$, the refresh function is defined as
	\begin{align*}
		R(c) = c \bmod R_k
	\end{align*}
\end{description}
\section{A Case Where Decryption Fails}
We consider the following quantity:
\begin{align}
	\label{eq:cornercase_ciphertext}
	D(\underbrace{E(1)+E(1)+\cdots+E(1)}_{S_k \text{ times}}).
\end{align}
Since $S_k$ is odd, the corresponding operation in the plaintext space is
\begin{align*}
	\label{eq:cornercase_plaintext}
	\underbrace{1 \text{ XOR } 1 \text{ XOR } \cdots \text{ XOR } 1}_{S_k \text{ times}} = 1.
\end{align*}
However, evaluating Equation \ref{eq:cornercase_ciphertext} yields:
\begin{align*}
	D(\underbrace{E(1)+E(1)+\cdots+E(1)}_{S_k \text{ times}})
	&= D\left(\sum_{i=1}^{S_k}{(1+S_kr_i)}\right)\\
	&= D\left(S_k + S_k\sum_{i=1}^{S_k}{r_i}\right)\\
	&= \left(S_k + S_k\sum_{i=1}^{S_k}{r_i}\right) \bmod S_k \bmod 2\\
	&= 0 \bmod 2\\
	&= 0.
\end{align*}
Since $1\neq 0$, we have shown an instance where incorrect decryption occurs given a sequence of operations on ciphertexts.
In general, a ciphertext in the Dasgupta-Pal cryptosystem is composed of a \textit{message-carrying addend} $A_m$ and a \textit{secret key addend} $A_s$ which is divisible by $S_k$. The message-carrying addend maintains the parity of the encoded bit, while the secret key addend obfuscates the message. This is maintained even when homomorphic operations are applied to ciphertexts:
\begin{align*}
	E(a) &= \underbrace{a}_{A_m} + \underbrace{S_kr}_{A_s}\\
	E(a)+E(b) &= (a + S_kr_1) + (b + S_kr_2)\\
	&= \underbrace{a+b}_{A_m} + \underbrace{S_k(r_1 + r_2)}_{A_s}\\
	E(a)\times E(b) &= (a + S_kr_1) \times (b + S_kr_2)\\
	&= \underbrace{ab}_{A_m} + \underbrace{S_k(br_1 + ar_2 + S_kr_1r_2)}_{A_s}
\end{align*}

Errors may occur in decryption when the message-carrying addend exceeds $S_k$.

The refresh function does not remedy this error: since $R_k > S_k$, refreshing the ciphertexts

\subsection{Correction to the Dasgupta-Pal Cryptosystem}
We now show that setting the secret key $S_k$ to $2p$, where $p$ is a prime, fixes the issue in the original cryptosystem.
